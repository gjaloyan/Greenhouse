#include "esp_system.h"
#include "esp_event.h"
#include "esp_wifi.h"
#include "nvs_flash.h"
#include "esp_netif.h"
#include "esp_log.h"
#include "mqtt_client.h"
#include "driver/uart.h"
#include "driver/gpio.h"

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "freertos/event_groups.h"

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "cJSON.h"

#define TAG "GREENHOUSE"
#define NVS_NAMESPACE "greenhouse"  // Namespace для NVS, аналог в Preferences

// ESP32 pin definitions
#define RS485_TX_PIN   17   // UART2 TX
#define RS485_RX_PIN   16   // UART2 RX
#define RS485_CONTROL_PIN 4 // DE/RE pin for RS485

// Use Hardware Serial for relay control
#define RELAY_TX_PIN   14   // UART1 TX
#define RELAY_RX_PIN   15   // UART1 RX
#define UART_RELAY_NUM UART_NUM_1
#define UART_RS485_NUM UART_NUM_2

// Настройки WiFi
const char* ssid =   "TEAM-51";
const char* password = "26839269.";

// Настройки MQTT
const char* mqtt_server = "34.71.239.197";
const int mqtt_port = 1883;
const char* mqtt_user = "gjaloyan";
const char* mqtt_password = "26839269";
const char* mqtt_client_id = "ESP32_Greenhouse";
const char* greenhouse_id = "Greenhouse1"; // Уникальный ID этой теплицы

// MQTT Topics
const char* topic_sht20 = "sensors/sht20";
const char* topic_sht20_read = "sensors/sht20/read";
const char* topic_bmp280 = "sensors/bmp280";
const char* topic_bmp280_read = "sensors/bmp280/read";
const char* topic_ldr = "sensors/ldr";
const char* topic_ldr_read = "sensors/ldr/read";
const char* topic_relay_command = "relay/command";
const char* topic_relay_status = "relay/status";
const char* topic_relay_status_get = "relay/status/get";
const char* topic_greenhouse_status = "greenhouse/status";
const char* topic_greenhouse_status_get = "greenhouse/status/get";

//Ventilation Topics
const char* topic_ventilation_command = "ventilation/command";
const char* topic_ventilation_status = "ventilation/status";
const char* ventilation_setpoints = "ventilation/setpoints";
const char* ventilation_setpoints_get = "ventilation/setpoints/get";
// const char* ventilation_command_manual = "ventilation/command/manual";
// const char* ventilation_command_auto = "ventilation/command/auto";

//Cooling Topics 
const char* topic_cooling_command = "cooling/command";
const char* topic_cooling_status = "cooling/status";
const char* topic_cooling_setpoints = "cooling/setpoints";
const char* topic_cooling_setpoints_get = "cooling/setpoints/get";
const char* topic_cooling_command_ventilator_start = "cooling/command/ventilator/start";
const char* topic_cooling_command_ventilator_stop = "cooling/command/ventilator/stop";
// const char* topic_cooling_command_manual = "cooling/command/manual";
// const char* topic_cooling_command_auto = "cooling/command/auto";



StaticJsonDocument<200> RelayState;


esp_mqtt_client_handle_t mqtt_client = NULL;

// Variables
unsigned long lastMsg = 0;
unsigned long sensorPollInterval = 10000; // 10 seconds
bool relayStatus[4] = {false, false, false, false};
float temperature = 0.0;
float humidity    = 0.0;

// Ventilation System Variables
const char* ventilationStatus = "closed";
float ventilation_temperature_setpoint = 26.0;
bool ventilation_control_auto_state = false;
unsigned long ventilation_open_coefficient = 500;

unsigned long ventilation_start_time = 0;
unsigned long ventilation_open_duration = 0;
int ventilation_percent_target = 0;
bool ventilation_in_progress = false;
int current_ventilation_percent = 0;
int ventilation_wind_speed_setpoint = 0;
int wind_speed_current = 0;
float ventilation_emergency_off_temperature = 0;

//Cooling System Variables
float cooling_target_temperature = 0;
float cooling_emergency_off_temperature = 0;
bool cooling_control_auto_state = false;
bool cooling_system_active = false;
bool cooling_water_pump_status = false;
bool cooling_ventilators_status[4] = {false, false, false, false};

// int cooling_ventilators_intensity_setpoint = 0;

// FreeRTOS event group для синхронизации
static EventGroupHandle_t wifi_event_group;
const int WIFI_CONNECTED_BIT = BIT0;
const int MQTT_CONNECTED_BIT = BIT1;

// Modbus related variables
SemaphoreHandle_t modbus_mutex = NULL;

// Prototypes for ESP-IDF functions
static void wifi_event_handler(void* arg, esp_event_base_t event_base, 
                              int32_t event_id, void* event_data);
static void mqtt_event_handler(void *handler_args, esp_event_base_t base, 
                              int32_t event_id, void *event_data);
void handle_mqtt_message(const char* topic, const char* data, int data_len);
void app_main(void);
void configure_uart(void);
void turn_on_relay(int relay_num);
void turn_off_relay(int relay_num);
void modbus_pre_transmission(void);
void modbus_post_transmission(void);
void publish_ventilation_status(void);
void ventilation_control_auto(void);
void read_sht20_data(void);
void sensor_task(void *pvParameters);

// Prototypes for ESP-IDF functions
esp_err_t nvs_save_bool(const char* key, bool value);
esp_err_t nvs_save_int(const char* key, int32_t value);
esp_err_t nvs_save_float(const char* key, float value);
bool nvs_get_bool(const char* key, bool default_value);
int32_t nvs_get_int(const char* key, int32_t default_value);
float nvs_get_float(const char* key, float default_value);
void load_settings_from_nvs(void);
void save_relay_state(void);
void save_ventilation_settings(void);
void save_cooling_settings(void);

// WiFi event handler function
static void wifi_event_handler(void* arg, esp_event_base_t event_base, 
                              int32_t event_id, void* event_data) {
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        ESP_LOGI(TAG, "WiFi station started, connecting...");
        esp_wifi_connect();
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
        ESP_LOGI(TAG, "WiFi disconnected, trying to reconnect...");
        esp_wifi_connect();
        xEventGroupClearBits(wifi_event_group, WIFI_CONNECTED_BIT);
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        ESP_LOGI(TAG, "WiFi connected! IP address: " IPSTR, IP2STR(&event->ip_info.ip));
        xEventGroupSetBits(wifi_event_group, WIFI_CONNECTED_BIT);
    }
}

// MQTT event handler function
static void mqtt_event_handler(void *handler_args, esp_event_base_t base, 
                              int32_t event_id, void *event_data) {
    esp_mqtt_event_handle_t event = event_data;
    switch (event->event_id) {
        case MQTT_EVENT_CONNECTED:
            ESP_LOGI(TAG, "MQTT Connected");
            xEventGroupSetBits(wifi_event_group, MQTT_CONNECTED_BIT);
            
            // Подписка на MQTT топики
            ESP_LOGI(TAG, "Subscribing to MQTT topics...");
            
            // Sensors
            esp_mqtt_client_subscribe(mqtt_client, topic_sht20_read, 0);
            esp_mqtt_client_subscribe(mqtt_client, topic_bmp280_read, 0);
            esp_mqtt_client_subscribe(mqtt_client, topic_ldr_read, 0);
            
            // Relay control
            esp_mqtt_client_subscribe(mqtt_client, topic_relay_command, 0);
            esp_mqtt_client_subscribe(mqtt_client, topic_relay_status_get, 0);
            esp_mqtt_client_subscribe(mqtt_client, topic_greenhouse_status_get, 0);
            
            // Ventilation
            esp_mqtt_client_subscribe(mqtt_client, topic_ventilation_command, 0);
            esp_mqtt_client_subscribe(mqtt_client, topic_ventilation_status, 0);
            esp_mqtt_client_subscribe(mqtt_client, ventilation_setpoints, 0);
            
            // Cooling
            esp_mqtt_client_subscribe(mqtt_client, topic_cooling_command, 0);
            esp_mqtt_client_subscribe(mqtt_client, topic_cooling_status, 0);
            esp_mqtt_client_subscribe(mqtt_client, topic_cooling_setpoints, 0);
            esp_mqtt_client_subscribe(mqtt_client, topic_cooling_setpoints_get, 0);
            
            ESP_LOGI(TAG, "Successfully subscribed to all topics");
            break;
        case MQTT_EVENT_DISCONNECTED:
            ESP_LOGI(TAG, "MQTT Disconnected");
            xEventGroupClearBits(wifi_event_group, MQTT_CONNECTED_BIT);
            break;
        case MQTT_EVENT_DATA:
            ESP_LOGI(TAG, "MQTT Data Received:");
            ESP_LOGI(TAG, "TOPIC=%.*s", event->topic_len, event->topic);
            ESP_LOGI(TAG, "DATA=%.*s", event->data_len, event->data);
            
            // Копируем тему и данные во временные буферы для обработки
            char topic[128];
            char data[512];
            
            // Обеспечиваем завершенные нулем строки
            if (event->topic_len < sizeof(topic) - 1) {
                memcpy(topic, event->topic, event->topic_len);
                topic[event->topic_len] = '\0';
            } else {
                ESP_LOGE(TAG, "Topic too long, truncating");
                memcpy(topic, event->topic, sizeof(topic) - 1);
                topic[sizeof(topic) - 1] = '\0';
            }
            
            if (event->data_len < sizeof(data) - 1) {
                memcpy(data, event->data, event->data_len);
                data[event->data_len] = '\0';
            } else {
                ESP_LOGE(TAG, "Data too long, truncating");
                memcpy(data, event->data, sizeof(data) - 1);
                data[sizeof(data) - 1] = '\0';
            }
            
            // Обрабатываем сообщение в зависимости от топика
            handle_mqtt_message(topic, data, event->data_len);
            break;
        default:
            break;
    }
}

// Initialize WiFi in station mode
static void wifi_init_sta(void) {
    wifi_event_group = xEventGroupCreate();
    
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    esp_netif_create_default_wifi_sta();
    
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));
    
    // Register event handlers
    esp_event_handler_instance_t instance_any_id;
    esp_event_handler_instance_t instance_got_ip;
    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,
                                                       ESP_EVENT_ANY_ID,
                                                       &wifi_event_handler,
                                                       NULL,
                                                       &instance_any_id));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,
                                                       IP_EVENT_STA_GOT_IP,
                                                       &wifi_event_handler,
                                                       NULL,
                                                       &instance_got_ip));
    
    // Configure WiFi station with credentials
    wifi_config_t wifi_config = {
        .sta = {
            .threshold.authmode = WIFI_AUTH_WPA2_PSK,
        },
    };
    memcpy(wifi_config.sta.ssid, ssid, strlen(ssid));
    memcpy(wifi_config.sta.password, password, strlen(password));
    
    // Disable power save to avoid GPIO2 conflict
    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config));
    ESP_ERROR_CHECK(esp_wifi_set_ps(WIFI_PS_NONE));
    ESP_ERROR_CHECK(esp_wifi_start());
    
    ESP_LOGI(TAG, "wifi_init_sta finished");
    
    /* Waiting until either the connection is established (WIFI_CONNECTED_BIT) or connection failed for the maximum
     * number of re-tries (5) */
    EventBits_t bits = xEventGroupWaitBits(wifi_event_group, WIFI_CONNECTED_BIT,
                                           pdFALSE, pdFALSE, portMAX_DELAY);
                                           
    if (bits & WIFI_CONNECTED_BIT) {
        ESP_LOGI(TAG, "Connected to AP SSID:%s", ssid);
    } else {
        ESP_LOGE(TAG, "Failed to connect to SSID:%s", ssid);
    }
}

// Initialize MQTT client
static void mqtt_app_start(void) {
    esp_mqtt_client_config_t mqtt_cfg = {
        .uri = mqtt_server,
        .port = mqtt_port,
        .username = mqtt_user,
        .password = mqtt_password,
        .client_id = mqtt_client_id,
    };
    
    mqtt_client = esp_mqtt_client_init(&mqtt_cfg);
    esp_mqtt_client_register_event(mqtt_client, ESP_EVENT_ANY_ID, mqtt_event_handler, NULL);
    esp_mqtt_client_start(mqtt_client);
}

// Initialize UART for relay control and RS485
void configure_uart(void) {
    // Configure UART for relay control
    uart_config_t uart_config_relay = {
        .baud_rate = 115200,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_APB,
    };
    
    uart_param_config(UART_RELAY_NUM, &uart_config_relay);
    uart_set_pin(UART_RELAY_NUM, RELAY_TX_PIN, RELAY_RX_PIN, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
    uart_driver_install(UART_RELAY_NUM, 256, 0, 0, NULL, 0);
    
    // Configure UART for RS485
    uart_config_t uart_config_rs485 = {
        .baud_rate = 9600,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_APB,
    };
    
    uart_param_config(UART_RS485_NUM, &uart_config_rs485);
    uart_set_pin(UART_RS485_NUM, RS485_TX_PIN, RS485_RX_PIN, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
    uart_driver_install(UART_RS485_NUM, 256, 0, 0, NULL, 0);
    
    // Configure RS485 control pin
    gpio_config_t io_conf = {
        .pin_bit_mask = (1ULL << RS485_CONTROL_PIN),
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE,
    };
    gpio_config(&io_conf);
    gpio_set_level(RS485_CONTROL_PIN, 0); // Start in receive mode
}

// Main function for ESP-IDF
void app_main(void) {
    // Initialize NVS (Non-Volatile Storage)
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    
    // Log system startup
    ESP_LOGI(TAG, "\n\nInitializing system...");
    
    // Create modbus mutex
    modbus_mutex = xSemaphoreCreateMutex();
    
    // Load settings from NVS
    load_settings_from_nvs();
    
    // Initialize WiFi (with corrected setup to avoid GPIO2 conflict)
    wifi_init_sta();
    
    // Configure UART for relay control and RS485
    configure_uart();
    
    // Start MQTT client
    mqtt_app_start();
    
    // Create FreeRTOS tasks for periodic operations
    xTaskCreate(sensor_task, "sensor_task", 4096, NULL, 5, NULL);
    
    // Main loop as an infinite loop task
    ESP_LOGI(TAG, "System initialized and running");
    while (1) {
        // Check ventilation progress
        if (ventilation_in_progress && (esp_timer_get_time()/1000 - ventilation_start_time >= ventilation_open_duration)) {
            ventilation_control_stop();
            ventilation_in_progress = false;
            ESP_LOGI(TAG, "Ventilation movement complete. Now at %d%%", current_ventilation_percent);
        }

        if (wind_speed_current > ventilation_wind_speed_setpoint) {
            ventilation_control_stop();
            ventilation_in_progress = false;
            ESP_LOGI(TAG, "Wind speed is very high. Ventilation stopped");
        }
        
        vTaskDelay(100 / portTICK_PERIOD_MS);
    }
}

// Sensor data reading and auto control task
void sensor_task(void *pvParameters) {
    TickType_t xLastWakeTime = xTaskGetTickCount();
    
    while(1) {
        if (xEventGroupGetBits(wifi_event_group) & MQTT_CONNECTED_BIT) {
            read_sht20_data();
            ventilation_control_auto();
            // read_wind_speed();
            
            // Publish data if needed
            if (esp_mqtt_client_get_state(mqtt_client) == MQTT_STATE_CONNECTED) {
                // Publish any periodic data
            }
        }
        
        vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(sensorPollInterval));
    }
}

// Implementations of functions to control relays
void turn_on_relay(int relay_num) {
    uint8_t command[] = {0xA0, (uint8_t)relay_num, 0x01, (uint8_t)(0xA0 + relay_num + 1)};
    uart_write_bytes(UART_RELAY_NUM, (const char*)command, sizeof(command));
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    
    // Retry to ensure command is sent
    uart_write_bytes(UART_RELAY_NUM, (const char*)command, sizeof(command));
    ESP_LOGI(TAG, "Relay %d turned on successfully", relay_num);
    
    // Update relay state in your tracking variables
}

void turn_off_relay(int relay_num) {
    uint8_t command[] = {0xA0, (uint8_t)relay_num, 0x00, (uint8_t)(0xA0 + relay_num)};
    uart_write_bytes(UART_RELAY_NUM, (const char*)command, sizeof(command));
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    
    // Retry to ensure command is sent
    uart_write_bytes(UART_RELAY_NUM, (const char*)command, sizeof(command));
    ESP_LOGI(TAG, "Relay %d turned off successfully", relay_num);
    
    // Update relay state in your tracking variables
}

void loop() {

  if (!mqtt_client.connected()) {
    reconnectMQTT();
  }
  mqtt_client.loop();

if (ventilation_in_progress && (millis() - ventilation_start_time >= ventilation_open_duration)) {
  ventilation_control_stop();
  ventilation_in_progress = false;
  Serial.println("Ventilation movement complete. Now at " + String(current_ventilation_percent) + "%");
}

if (wind_speed_current > ventilation_wind_speed_setpoint){
  ventilation_control_stop();
  ventilation_in_progress = false;
  Serial.println("Vindspeed is very high. Ventilation stopped");
}



  // Publish sensor data periodically
  unsigned long now = millis();
  if (now - lastMsg > sensorPollInterval) {
    lastMsg = now;
    readSHT20Data();
    ventilation_control_auto();
    // readWindSpeed();
  }
}

void publishGreenhouseStatus(){
  StaticJsonDocument<200> doc;
  doc["status"] = "online";
  doc["client_id"] = mqtt_client_id;
  doc["greenhouse_id"] = greenhouse_id;
  
  char buffer[200];
  serializeJson(doc, buffer);
  
  sendMQTTData(topic_greenhouse_status, buffer);
}



void mqtt_callback(char* topic, byte* payload, unsigned int length) {
  // Convert payload to string
  char message[length + 1];
  for (int i = 0; i < length; i++) {
    message[i] = (char)payload[i];
  }
  message[length] = '\0';
  
  String topicStr = String(topic);
  String messageStr = String(message);
  const char* action = ""; 
  int actionValue = 0; // Добавляем переменную для числовых значений действий
  int actionValue2 = 0; // Добавляем переменную для числовых значений действий
  float setpointTemperature = 0;
  int setpointCoefficient = 0;
  int setpointWindSpeed = 0;

  float coolingSetpointTemperature = 0;
  float coolingEmergencyOffTemperature = 0;
  bool coolingControlAutoState = false;
  
  Serial.print("Message arrived [");
  Serial.print(topic);
  Serial.print("]: ");
  Serial.println(messageStr);

  // Проверяем, адресовано ли сообщение этой теплице
  // Если сообщение содержит JSON, проверяем поле target_greenhouse
  bool messageForThisGreenhouse = true; // По умолчанию обрабатываем
  
  if (messageStr.indexOf("{") >= 0) {
    // Если сообщение содержит JSON структуру
    StaticJsonDocument<400> doc;
    DeserializationError error = deserializeJson(doc, messageStr);

    if (!error && doc.containsKey("target_greenhouse")) {
      // Если сообщение содержит поле target_greenhouse
      const char* targetId = doc["target_greenhouse"];
      
      // Проверяем, есть ли поле action
      if (doc.containsKey("action")) {
        // Сохраняем значение action в зависимости от его типа
        if (doc["action"].is<int>()) {
          // Если action - число (для вентиляции)
          actionValue = doc["action"].as<int>();
          action = ""; // Строковое значение пустое, так как action числовой
        } else if (doc["action"].is<const char*>()) {
          // Если action - строка (для других команд)
          action = doc["action"].as<const char*>();
        }
      }


      if (doc.containsKey("ventilation_setpoint_temperature")) {
        setpointTemperature = doc["ventilation_setpoint_temperature"].as<float>();
        setpointCoefficient = doc["ventilation_setpoint_coefficient"].as<int>();
        setpointWindSpeed = doc["ventilation_setpoint_wind_speed"].as<int>();
        ventilation_emergency_off_temperature = doc["ventilation_emergency_off_temperature"].as<float>();
      }
      if (doc.containsKey("cooling_setpoint_temperature")) {
        coolingSetpointTemperature = doc["cooling_setpoint_temperature"].as<float>();
        coolingEmergencyOffTemperature = doc["cooling_emergency_off_temperature"].as<float>();
        coolingControlAutoState = doc["cooling_control_auto_state"].as<bool>();
      }

      messageForThisGreenhouse = (strcmp(targetId, greenhouse_id) == 0);
      
      if (!messageForThisGreenhouse) {
        Serial.println("Message is for a different greenhouse. Ignoring.");
        return; // Не обрабатываем сообщение
      }
    }
    
    // Проверка: если сообщение содержит наш собственный greenhouse_id и это сообщение о статусе вентиляции,
    // то это наше собственное сообщение, которое мы отправили - игнорируем его
    if (!error && doc.containsKey("greenhouse_id") && strcmp(doc["greenhouse_id"], greenhouse_id) == 0) {
      if (topicStr == topic_ventilation_status) {
        Serial.println("Ignoring our own ventilation status message");
        return; // Пропускаем обработку нашего собственного сообщения
      }
    }
  }
  
  String actionStr = String(action);
 
  // Продолжаем обработку сообщения, если оно для этой теплицы
  // Handle sensor read requests
  if (topicStr == topic_sht20_read && actionStr == "request") {
    publishSHT20Data();
  } 
  else if (topicStr == topic_bmp280_read && actionStr == "request") {
    // publishBMP280Data();
  }
  else if (topicStr == topic_ldr_read && actionStr == "request") {
    // publishLDRData();
  }
    // Handle relay commands
  else if (topicStr == topic_relay_command) {
    handleRelayCommand(actionStr);
  }

  // Ventilation
  else if (topicStr == topic_ventilation_command) {
    ventilation_control_open_percent(actionValue);
    saveVentilationSettings();
  }
  else if (topicStr == topic_ventilation_command && actionStr == "auto") {
    ventilation_control_auto_state = true;
    ventilation_control_open_percent(0);
    ventilation_control_auto();
    saveVentilationSettings();
  }
  else if (topicStr == topic_ventilation_command && actionStr == "manual") {
    ventilation_control_auto_state = false;
    ventilation_control_open_percent(0);
    saveVentilationSettings();
  }
  else if (topicStr == topic_ventilation_status && actionStr == "get") {
    publishVentilationStatus();
  }
  else if (topicStr == topic_greenhouse_status_get) {
    publishGreenhouseStatus();
  }
  else if (topicStr == ventilation_setpoints) {
    setVentilationSetpoints(setpointTemperature, setpointCoefficient, setpointWindSpeed, ventilation_emergency_off_temperature);
  }
  else if (topicStr == ventilation_setpoints_get && actionStr == "get") {
    publishVentilationSetpoints();
  }

  // Cooling
  else if (topicStr == topic_cooling_setpoints_get && actionStr == "get") {
    publishCoolingSetpoints();
  }
  else if (topicStr == topic_cooling_setpoints) {
    setCoolingSetpoints(coolingSetpointTemperature, coolingEmergencyOffTemperature, coolingControlAutoState);
  }
  else if (topicStr == topic_cooling_status && actionStr == "get") {
    publishCoolingStatus();
  }
  else if (topicStr == topic_cooling_command) {
    cooling_system_start(actionValue);
  }
  else if (topicStr == topic_cooling_command_ventilator_start) {
    startVentilator(actionValue);
  }
  else if (topicStr == topic_cooling_command_ventilator_stop) {
    stopVentilator(actionValue);
  }
  else if (topicStr == topic_cooling_command && actionStr == "manual") {
    cooling_control_auto_state = false;
    cooling_system_stop();
    saveCoolingSettings();
  }
  else if (topicStr == topic_cooling_command && actionStr == "auto") {
    cooling_control_auto_state = true;
    cooling_control_auto();
    saveCoolingSettings();
  }

  // Handle status requests
  else if (topicStr == topic_relay_status_get) {
    if (actionStr == "all") {
      publishAllRelayStatus();
    } else {
      // Check if it's a specific relay request
      if (actionStr == "r1") publishRelayStatus(1);
      else if (actionStr == "r2") publishRelayStatus(2);
      else if (actionStr == "r3") publishRelayStatus(3);
      else if (actionStr == "r4") publishRelayStatus(4);
    }
  }
}

// Handle relay command
void handleRelayCommand(String command) {
  int relayIndex = 1;
  bool turnOn = true;
  
  // Extract relay index (1-based in command, 0-based in array)
  if (command.startsWith("r1")) {
    relayIndex = 1;
  } else if (command.startsWith("r2")) {
    relayIndex = 2;
  } else if (command.startsWith("r3")) {
    relayIndex = 3;
  } else if (command.startsWith("r4")) {
    relayIndex = 4;
  }
  
  
  // Check if this is an OFF command
  if (command.endsWith("_OFF")) {
    turnOn = false;
  }
  
  // Apply the command if valid
  if (relayIndex >= 0) {
    // Get physical pin
    // int pin;
    // switch (relayIndex) {
    //   case 0: pin = RELAY1_PIN; break;
    //   case 1: pin = RELAY2_PIN; break;
    //   case 2: pin = RELAY3_PIN; break;
    //   case 3: pin = RELAY4_PIN; break;
    // }
    
    // Set pin state
    if(turnOn){
      turn_on_relay(relayIndex);
    }
    else{
      turn_off_relay(relayIndex);
    }
    relayStatus[relayIndex - 1] = turnOn;
    
    // Update status
    publishRelayStatus(relayIndex);
  }
}

// Publish data from all sensors
void publishSensorData() {
  publishSHT20Data();
  // publishBMP280Data();
  // publishLDRData();
}

void sendMQTTData(const char* topic, const char* data) {
    if (!mqtt_client.connected()) {
    reconnectMQTT();
  }
  esp_mqtt_client_publish(mqtt_client, topic, data, 0, 0);
};

void sendMQTTMessage(const char* topic, const char* message) {
  if (!mqtt_client.connected()) {
    reconnectMQTT();
  }
  esp_mqtt_client_publish(mqtt_client, topic, message, 0, 0);
}

void readWindSpeed(){
  const int maxAttempts = 50;  // Maximum number of retry attempts
  int attempt = 0;
  bool success = false;
  while (attempt < maxAttempts && !success) {
    // Установить ID устройства (slave ID) для конкретного датчика
    // node.setServerID(2);  // Поменяйте на ID вашего датчика (обычно 1-247)
    // Чтение данных с конкретного регистра
    uint8_t result = node.readInputRegisters(2, 1);
    if (result == node.ku8MBSuccess) {
      uint16_t rawWindSpeed = node.getResponseBuffer(0);

      // // Для float значения (4 байта / 2 регистра)
      // union {
      //   uint16_t words[2];
      //   float value;
      // } data;

      // data.words[0] = rawWindSpeed;
      // data.words[1] = 0;
      // float sensorValue = data.value;


      wind_speed_current = rawWindSpeed / 10.0;

      success = true;

    } else {
      Serial.print("Modbus wind speed read error. Code: 0x");
      Serial.println(result, HEX);
      attempt++;
      // Increase delay to allow the sensor more time to respond
      delay(500);  
    }
  }

  if (!success) {
    Serial.println("Failed to read wind speed sensor data after multiple attempts.");
  }
  // Read wind speed from wind speed sensor
  // TODO: Implement wind speed reading
  wind_speed_current = 0; // Placeholder value
}


void readSHT20Data() {
  const int maxAttempts = 50;  // Maximum number of retry attempts
  int attempt = 0;
  bool success = false;
  while (attempt < maxAttempts && !success) {
    // Set RS485 to TX mode before reading
    // node.preTransmission(preTransmission);
    uint8_t result = node.readInputRegisters(1, 2);
    // uint8_t result = node.readHoldingRegisters(1, 2);  // Try this instead
    // Always set RS485 back to RX mode after the read attempt
    // node.postTransmission(postTransmission);
    if (result == node.ku8MBSuccess) {
      uint16_t rawTemperature = node.getResponseBuffer(0);
      uint16_t rawHumidity    = node.getResponseBuffer(1);

      temperature = rawTemperature / 10.0;
      humidity    = rawHumidity / 10.0;

      success = true;

    } else {
      Serial.print("Modbus temperature and humidity read error. Code: 0x");
      Serial.println(result, HEX);
      attempt++;
      // Increase delay to allow the sensor more time to respond
      delay(500);  
    }
  }

  if (!success) {
    Serial.println("Failed to read temperature and humidity sensor data after multiple attempts.");
  }
}

void publishSHT20Data(){
  readSHT20Data();
  StaticJsonDocument<200> doc;
  doc["temperature"] = temperature;
  doc["humidity"] = humidity;
  doc["client_id"] = mqtt_client_id;
  doc["greenhouse_id"] = greenhouse_id;

  char jsonBuffer[200];
  serializeJson(doc, jsonBuffer);
  
  sendMQTTData(topic_sht20, jsonBuffer);
  Serial.println("Data Sent");
}


// Publish status of all relays
void publishAllRelayStatus() {
  StaticJsonDocument<200> doc;
  doc["r1"] = relayStatus[0] ? "ON" : "OFF";
  doc["r2"] = relayStatus[1] ? "ON" : "OFF";
  doc["r3"] = relayStatus[2] ? "ON" : "OFF";
  doc["r4"] = relayStatus[3] ? "ON" : "OFF";
  doc["greenhouse_id"] = greenhouse_id;
  
  char buffer[200];
  serializeJson(doc, buffer);
  
  // Publish
  sendMQTTData(topic_relay_status, buffer);
}

// Publish status of a specific relay
void publishRelayStatus(int relayIndex) {
  if (relayIndex < 0 || relayIndex > 4) return;
  
  String relayId = "r" + String(relayIndex);
  int relay = relayIndex - 1;
  String state;
  if(relayStatus[relay]){
    state = "ON";
  }else{
    state = "OFF";
  }

  
  StaticJsonDocument<100> doc;
  doc[relayId] = state;
  doc["greenhouse_id"] = greenhouse_id;
  
  char buffer[100];
  serializeJson(doc, buffer);
  
  // Publish
  sendMQTTData(topic_relay_status, buffer);
} 


//Ventilation System
void ventilation_control_open(void) {
    turn_on_relay(4);
    vTaskDelay(100 / portTICK_PERIOD_MS);
    if (relayStatus[3] == true) {
        ventilationStatus = "open";
        current_ventilation_percent = 100;
    } else {
        ventilationStatus = "open_error";
    }
    ESP_LOGI(TAG, "Ventilation opened");
}

void ventilation_control_close(void) {
    turn_on_relay(3);
    vTaskDelay(100 / portTICK_PERIOD_MS);
    if (relayStatus[2] == true) {
        ventilationStatus = "closed";
        current_ventilation_percent = 0;
    } else {
        ventilationStatus = "closed_error";
    }
    ESP_LOGI(TAG, "Ventilation closed");
}

void ventilation_control_stop(void) {
    turn_off_relay(3);
    turn_off_relay(4);
    vTaskDelay(100 / portTICK_PERIOD_MS);
    if (relayStatus[2] == false && relayStatus[3] == false) {
        ventilationStatus = "stopped";
        current_ventilation_percent = ventilation_percent_target;
    } else {
        ventilationStatus = "stopped_error";
    }
    nvs_save_int("vent_percent", current_ventilation_percent);
    publish_ventilation_status();
    save_ventilation_settings();
    ESP_LOGI(TAG, "Ventilation stopped at %d%%", current_ventilation_percent);
}

void ventilation_control_open_percent(int target_percent) {
    if (cooling_system_active == true) {
        ESP_LOGI(TAG, "Cooling system is active, turning off cooling system");
        cooling_system_stop();
    }
    
    // Validate input range
    if (target_percent < 0) target_percent = 0;
    if (target_percent > 100) target_percent = 100;
    
    // Calculate the relative movement needed
    int relative_change = target_percent - current_ventilation_percent;
    
    if (relative_change == 0) {
        // No change needed
        ESP_LOGI(TAG, "Ventilation already at %d%%", current_ventilation_percent);
        publish_ventilation_status();
        return;
    }
    
    // Calculate duration based on the absolute value of relative change
    int ventilation_open_interval = abs(relative_change) * ventilation_open_coefficient;
    
    ESP_LOGI(TAG, "Current position: %d%%, Target: %d%%, Relative change: %d%%", 
             current_ventilation_percent, target_percent, relative_change);
    
    if (relative_change < 0) {
        ESP_LOGI(TAG, "Ventilation closing from %d%% to %d%% (Moving %d%%)",
                current_ventilation_percent, target_percent, abs(relative_change));
        // Partial close
        ventilation_control_close(); // Start closing motor
        // Set up variables for non-blocking operation
        ventilation_start_time = esp_timer_get_time() / 1000; // Convert to ms
        ventilation_open_duration = ventilation_open_interval;
        ventilation_percent_target = target_percent;
        ventilation_in_progress = true;
    } else {
        ESP_LOGI(TAG, "Ventilation opening from %d%% to %d%% (Moving %d%%)",
                current_ventilation_percent, target_percent, abs(relative_change));
        // Partial open
        ventilation_control_open(); // Start opening motor
        // Set up variables for non-blocking operation
        ventilation_start_time = esp_timer_get_time() / 1000; // Convert to ms
        ventilation_open_duration = ventilation_open_interval;
        ventilation_percent_target = target_percent;
        ventilation_in_progress = true;
    }
}

void publishVentilationStatus(){
  StaticJsonDocument<200> doc;
  doc["status"] = ventilationStatus;
  doc["percent"] = current_ventilation_percent;
  doc["auto_control"] = ventilation_control_auto_state;
  doc["greenhouse_id"] = greenhouse_id;
  
  char buffer[200];
  serializeJson(doc, buffer);
  
  sendMQTTData(topic_ventilation_status, buffer);
}

// void ventilation_control_auto(){
//   if(ventilation_control_auto_state){
//       if(temperature > ventilation_temperature_setpoint){
//         if(ventilationStatus == "closed"){
//           Serial.println("Temp is Hight Turning Opening ventilation");
//           ventilation_control_open_percent(25);
//       }else {
//         Serial.println("Temp is Hight but Ventilation turned on Du nothing");
//        }
//     }else if(temperature < ventilation_temperature_setpoint){
//       if(ventilationStatus == "open"){
//         Serial.println("Temp is Low Turning closing ventilation");
//         Serial.println(temperature);
//         Serial.println(ventilation_temperature_setpoint);
//         ventilation_control_close();
//       }else {
//         Serial.println("Temp is low but Ventilation turned off Du nothing");
//        }
//     }
//   }
// } 

void ventilation_control_auto(void){
  if (ventilation_control_auto_state) {
    if (temperature > ventilation_temperature_setpoint && 
        (strcmp(ventilationStatus, "closed") == 0 || strcmp(ventilationStatus, "stopped") == 0)) {
        ventilation_control_open_percent(25);
    } else if (temperature > ventilation_temperature_setpoint + 2) {
        ventilation_control_open_percent(50);
    } else if (temperature > ventilation_temperature_setpoint + 4) {
        ventilation_control_open_percent(75);
    } else if (temperature > ventilation_temperature_setpoint + 6) {
        ventilation_control_open_percent(100);
    } else if (temperature < ventilation_temperature_setpoint) {
        ventilation_control_open_percent(0);
    } else if (temperature < ventilation_emergency_off_temperature) {
        ventilation_control_open_percent(0);
    }
  } 
}


// Function to save ventilation settings
void saveVentilationSettings() {
  preferences.putFloat("temp_setpoint", ventilation_temperature_setpoint);
  preferences.putInt("vent_percent", current_ventilation_percent);
  preferences.putBool("auto_control", ventilation_control_auto_state);
  preferences.putInt("vent_coefficient", ventilation_open_coefficient);
  preferences.putFloat("ventilation_emergency_off_temperature", ventilation_emergency_off_temperature);
}

void setVentilationSetpoints(float temperature, int coefficient, int windSpeed, float emergency_off_temperature ){
  ventilation_temperature_setpoint = temperature;
  ventilation_open_coefficient = coefficient;
  ventilation_wind_speed_setpoint = windSpeed;
  ventilation_emergency_off_temperature = emergency_off_temperature;
  saveVentilationSettings();
  publishVentilationSetpoints();
}


void publishVentilationSetpoints(){
  StaticJsonDocument<200> doc;
  doc["temperature"] = (float)ventilation_temperature_setpoint;
  doc["coefficient"] = ventilation_open_coefficient;
  doc["wind_speed"] = ventilation_wind_speed_setpoint;
  doc["emergency_off_temperature"] = ventilation_emergency_off_temperature;
  doc["greenhouse_id"] = greenhouse_id;
  
  char buffer[200];
  serializeJson(doc, buffer);
  
  sendMQTTData(ventilation_setpoints_get, buffer);
}


//Cooling System


void startVentilator(int ventilatorIndex) {
    if (ventilatorIndex >= 1 && ventilatorIndex <= 4) {
        // Вентилятор 1 = реле 5, вентилятор 2 = реле 6, и т.д.
        int relayIndex = ventilatorIndex + 3;
        turn_on_relay(relayIndex);
        vTaskDelay(100 / portTICK_PERIOD_MS);
        
        if (relayStatus[relayIndex-1]) { // Массив relayStatus индексируется с 0
            cooling_ventilators_status[ventilatorIndex-1] = true;
            char key[8];
            snprintf(key, sizeof(key), "v%d", ventilatorIndex);
            nvs_save_bool(key, true);
            ESP_LOGI(TAG, "Ventilator %d turned on successfully", ventilatorIndex);
            publishCoolingStatus();
        } else {
            ESP_LOGE(TAG, "Ventilator %d turn on error", ventilatorIndex);
        }
    } else {
        ESP_LOGE(TAG, "Invalid ventilator index: %d", ventilatorIndex);
    }
}

void stopVentilator(int ventilatorIndex) {
    if (ventilatorIndex >= 1 && ventilatorIndex <= 4) {
        // Вентилятор 1 = реле 5, вентилятор 2 = реле 6, и т.д.
        int relayIndex = ventilatorIndex + 3;
        turn_off_relay(relayIndex);
        vTaskDelay(100 / portTICK_PERIOD_MS);
        
        if (!relayStatus[relayIndex-1]) { // Проверяем, что реле действительно выключено
            cooling_ventilators_status[ventilatorIndex-1] = false;
            char key[8];
            snprintf(key, sizeof(key), "v%d", ventilatorIndex);
            nvs_save_bool(key, false);
            ESP_LOGI(TAG, "Ventilator %d turned off successfully", ventilatorIndex);
            publishCoolingStatus();
        } else {
            ESP_LOGE(TAG, "Ventilator %d turn off error", ventilatorIndex);
        }
    } else {
        ESP_LOGE(TAG, "Invalid ventilator index: %d", ventilatorIndex);
    }
}

void publishCoolingSetpoints(){
  StaticJsonDocument<200> doc;
  doc["target_temperature"] = cooling_target_temperature;
  doc["emergency_off_temperature"] = cooling_emergency_off_temperature;
  doc["control_auto_state"] = cooling_control_auto_state;
  doc["client_id"] = mqtt_client_id;
  doc["greenhouse_id"] = greenhouse_id;
  
  char buffer[200];
  serializeJson(doc, buffer);
  
  sendMQTTData(topic_cooling_setpoints, buffer);
}

void publishCoolingStatus(){
  StaticJsonDocument<200> doc;
  doc["status"] = cooling_system_active;
  doc["ventilators"] = cooling_ventilators_status;
  doc["water_pump"] = cooling_water_pump_status;
  doc["water_pump"] = cooling_water_pump_status;
  doc["cooling_control_auto_state"] = cooling_control_auto_state;
  doc["client_id"] = mqtt_client_id;
  doc["greenhouse_id"] = greenhouse_id;

  
  char buffer[200];
  serializeJson(doc, buffer);
  
  sendMQTTData(topic_cooling_status, buffer);
}


void saveCoolingSettings() {
  preferences.putFloat("cooling_target_temperature", cooling_target_temperature);
  preferences.putFloat("cooling_emergency_off_temperature", cooling_emergency_off_temperature);
  preferences.putBool("cooling_control_auto_state", cooling_control_auto_state);
  preferences.putBool("cooling_system_active", cooling_system_active);
  for(int i = 0; i < sizeof(cooling_ventilators_status)/sizeof(cooling_ventilators_status[0]); i++){
    String key = "v" + String(i+1);
    preferences.putBool(key.c_str(), cooling_ventilators_status[i]);
  }
  preferences.putBool("cooling_water_pump_status", cooling_water_pump_status);
}

void setCoolingSetpoints(float target_temperature, float emergency_off_temperature, bool control_auto_state){
  cooling_target_temperature = target_temperature;
  cooling_emergency_off_temperature = emergency_off_temperature;
  cooling_control_auto_state = control_auto_state;
  save_cooling_settings();
  publishCoolingSetpoints();
}


void cooling_control_auto(void){
  if(cooling_control_auto_state){
    if(temperature > cooling_target_temperature && cooling_system_active == false){
      cooling_system_active = true;
      cooling_system_start(25);
    }else if(temperature > cooling_target_temperature + 2){
      cooling_system_start(50);
    }else if(temperature > cooling_target_temperature + 4){
      cooling_system_start(75);
    }else if(temperature > cooling_target_temperature + 6){
      cooling_system_start(100);
    }else if(temperature < cooling_target_temperature){
      cooling_system_stop();
    }else if(temperature < cooling_emergency_off_temperature){
      cooling_system_active = false;
      cooling_system_stop();
    }
  } 
}

// Start Cooling System

// Function to start cooling system, waiting for ventilation to fully close
void cooling_system_start(int percent) {
    // Check if ventilation is currently open
    if (current_ventilation_percent > 0 || ventilation_in_progress) {
        ESP_LOGI(TAG, "Waiting for ventilation to close before starting cooling system");
        // Close ventilation first
        ventilation_control_open_percent(0);
        
        // Wait until ventilation is fully closed
        unsigned long startWaitTime = esp_timer_get_time() / 1000;
        const unsigned long maxWaitTime = 60000; // Maximum wait time: 60 seconds
        
        // Wait until both conditions are met:
        // 1. current_ventilation_percent is 0
        // 2. ventilation_in_progress is false (movement has stopped)
        while (current_ventilation_percent > 0 || ventilation_in_progress) {
            // Check for timeout
            if (esp_timer_get_time() / 1000 - startWaitTime > maxWaitTime) {
                ESP_LOGW(TAG, "Timeout waiting for ventilation to close!");
                break;
            }
            
            // Process events while waiting
            vTaskDelay(100 / portTICK_PERIOD_MS);
            
            // Print status every 2 seconds
            if ((esp_timer_get_time() / 1000 - startWaitTime) % 2000 < 100) {
                ESP_LOGI(TAG, "Waiting for ventilation: %d%%, in_progress: %s", 
                        current_ventilation_percent, 
                        ventilation_in_progress ? "true" : "false");
            }
        }
        
        ESP_LOGI(TAG, "Ventilation closed successfully!");
    }
    
    // Now start cooling system with requested percentage
    ESP_LOGI(TAG, "Starting cooling system at %d%%", percent);
    
    // Normalize percent value
    percent = (percent < 0) ? 0 : ((percent > 100) ? 100 : percent);
    
    // Сначала остановим все вентиляторы для определенности
    cooling_system_stop_ventilators();
    
    // Turn on cooling fans based on percentage
    if (percent >= 25) {
        startVentilator(1); // First cooling ventilator
        cooling_system_active = true;
        cooling_ventilators_status[0] = true;
    }
    
    if (percent >= 50) {
        startVentilator(1);
        startVentilator(2); // Second cooling ventilator
        cooling_ventilators_status[1] = true;
        cooling_system_active = true;
    }
    
    if (percent >= 75) {
        startVentilator(1);
        startVentilator(2);
        startVentilator(3); // Third cooling ventilator
        cooling_ventilators_status[2] = true;
        cooling_system_active = true;
    }
    
    if (percent == 100) {
        startVentilator(1);
        startVentilator(2);
        startVentilator(3);
        startVentilator(4); // Fourth cooling ventilator
        cooling_ventilators_status[3] = true;
        cooling_system_active = true;
    }
    
    // Update cooling status
    save_cooling_settings();
    publishCoolingStatus();
}

void cooling_system_start_water_pump(void) {
    turn_on_relay(2);
    vTaskDelay(100 / portTICK_PERIOD_MS);
    if (relayStatus[1]) {
        cooling_water_pump_status = true;
    }
    nvs_save_bool("cooling_water_pump_status", cooling_water_pump_status);
    publishCoolingStatus();
}


// Stop Cooling System

void cooling_system_stop(void) {
    if (cooling_system_active) {
        cooling_system_stop_ventilators();
        cooling_system_stop_water_pump();
        cooling_system_active = false;
        save_cooling_settings();
        publishCoolingStatus();
        ESP_LOGI(TAG, "Cooling system stopped");
    }
}

void cooling_system_stop_ventilators(void) {
    for (int i = 0; i < sizeof(cooling_ventilators_status)/sizeof(cooling_ventilators_status[0]); i++) {
        // Вентилятор имеет индекс i+1 (от 1 до 4)
        stopVentilator(i+1); 
        vTaskDelay(100 / portTICK_PERIOD_MS);
    }
    // Убедимся, что все флаги выключены
    for (int i = 0; i < sizeof(cooling_ventilators_status)/sizeof(cooling_ventilators_status[0]); i++) {
        cooling_ventilators_status[i] = false;
    }
    cooling_system_active = false;
    save_cooling_settings();
    publishCoolingStatus();
    ESP_LOGI(TAG, "All cooling ventilators stopped");
}

void cooling_system_stop_water_pump(void) {
    turn_off_relay(2);
    vTaskDelay(100 / portTICK_PERIOD_MS);
    if (!relayStatus[1]) {
        cooling_water_pump_status = false;
    }
    nvs_save_bool("cooling_water_pump_status", cooling_water_pump_status);
    ESP_LOGI(TAG, "Cooling water pump stopped");
}

// RS485 modbus control functions
void modbus_pre_transmission(void) {
    gpio_set_level(RS485_CONTROL_PIN, 1);  // Set to TX mode
}

void modbus_post_transmission(void) {
    gpio_set_level(RS485_CONTROL_PIN, 0);  // Set to RX mode
}

// Modbus read functions
void read_sht20_data(void) {
    if (xSemaphoreTake(modbus_mutex, pdMS_TO_TICKS(1000)) != pdTRUE) {
        ESP_LOGE(TAG, "Failed to take modbus mutex");
        return;
    }
    
    const int maxAttempts = 50;
    int attempt = 0;
    bool success = false;
    
    // Implement Modbus RTU request
    uint8_t request[8];
    uint8_t response[8];
    size_t response_len = 0;
    
    // Modbus function 04 (Read Input Registers), starting at address 1, 2 registers
    request[0] = 1;  // Slave address
    request[1] = 4;  // Function code (read input registers)
    request[2] = 0;  // Starting address high byte
    request[3] = 1;  // Starting address low byte
    request[4] = 0;  // Number of registers high byte
    request[5] = 2;  // Number of registers low byte
    
    // Add CRC
    uint16_t crc = 0xFFFF;
    for (int pos = 0; pos < 6; pos++) {
        crc ^= (uint16_t)request[pos];
        for (int i = 8; i != 0; i--) {
            if ((crc & 0x0001) != 0) {
                crc >>= 1;
                crc ^= 0xA001;
            } else {
                crc >>= 1;
            }
        }
    }
    request[6] = crc & 0xFF;
    request[7] = (crc >> 8) & 0xFF;
    
    while (attempt < maxAttempts && !success) {
        modbus_pre_transmission();
        vTaskDelay(10 / portTICK_PERIOD_MS);
        
        uart_flush(UART_RS485_NUM);
        uart_write_bytes(UART_RS485_NUM, (const char*)request, 8);
        uart_wait_tx_done(UART_RS485_NUM, pdMS_TO_TICKS(100));
        
        modbus_post_transmission();
        vTaskDelay(50 / portTICK_PERIOD_MS);
        
        // Read response
        int read_len = uart_read_bytes(UART_RS485_NUM, response, sizeof(response), pdMS_TO_TICKS(500));
        
        if (read_len >= 7 && response[0] == 1 && response[1] == 4) {
            // Valid response
            uint16_t rawTemperature = (response[3] << 8) | response[4];
            uint16_t rawHumidity = (response[5] << 8) | response[6];
            
            temperature = rawTemperature / 10.0;
            humidity = rawHumidity / 10.0;
            
            success = true;
            ESP_LOGI(TAG, "SHT20 data read: Temperature=%.1f, Humidity=%.1f", temperature, humidity);
        } else {
            ESP_LOGW(TAG, "Modbus temperature and humidity read error, attempt %d", attempt);
            attempt++;
            vTaskDelay(500 / portTICK_PERIOD_MS);
        }
    }
    
    if (!success) {
        ESP_LOGE(TAG, "Failed to read temperature and humidity sensor data after multiple attempts");
    }
    
    xSemaphoreGive(modbus_mutex);
}

// Загрузка всех настроек из NVS при запуске
void load_settings_from_nvs(void) {
    ESP_LOGI(TAG, "Loading settings from NVS");
    
    // Загрузка состояний реле
    relayStatus[0] = nvs_get_bool("relay1", false);
    relayStatus[1] = nvs_get_bool("relay2", false);
    relayStatus[2] = nvs_get_bool("relay3", false);
    relayStatus[3] = nvs_get_bool("relay4", false);
    
    // Загрузка настроек вентиляции
    ventilation_control_auto_state = nvs_get_bool("vent_auto", true);
    ventilation_temperature_setpoint = nvs_get_float("vent_temp", 25.0);
    ventilation_open_coefficient = nvs_get_int("vent_coef", 5);
    ventilation_wind_speed_setpoint = nvs_get_int("vent_wind", 12);
    ventilation_emergency_off_temperature = nvs_get_float("vent_emerg", 5.0);
    
    // Загрузка настроек охлаждения
    cooling_control_auto_state = nvs_get_bool("cool_auto", true);
    cooling_target_temperature = nvs_get_float("cool_temp", 30.0);
    
    ESP_LOGI(TAG, "Settings loaded successfully");
}

// Сохранение состояний реле
void save_relay_state(void) {
    ESP_LOGI(TAG, "Saving relay states to NVS");
    nvs_save_bool("relay1", relayStatus[0]);
    nvs_save_bool("relay2", relayStatus[1]);
    nvs_save_bool("relay3", relayStatus[2]);
    nvs_save_bool("relay4", relayStatus[3]);
}

void send_mqtt_data(const char* topic, const char* data) {
    if (esp_mqtt_client_get_state(mqtt_client) != MQTT_STATE_CONNECTED) {
        ESP_LOGW(TAG, "MQTT not connected, cannot send data");
        return;
    }
    
    int msg_id = esp_mqtt_client_publish(mqtt_client, topic, data, 0, 1, 0);
    if (msg_id < 0) {
        ESP_LOGE(TAG, "Failed to publish to %s", topic);
    } else {
        ESP_LOGI(TAG, "Published to %s: %s (msg_id=%d)", topic, data, msg_id);
    }
}

void publish_sht20_data(void) {
    read_sht20_data();
    
    // Create JSON document using cJSON
    cJSON *doc = cJSON_CreateObject();
    cJSON_AddNumberToObject(doc, "temperature", temperature);
    cJSON_AddNumberToObject(doc, "humidity", humidity);
    cJSON_AddStringToObject(doc, "client_id", mqtt_client_id);
    cJSON_AddStringToObject(doc, "greenhouse_id", greenhouse_id);
    
    char *json_string = cJSON_Print(doc);
    
    send_mqtt_data(topic_sht20, json_string);
    ESP_LOGI(TAG, "SHT20 Data Sent");
    
    // Free allocated memory
    free(json_string);
    cJSON_Delete(doc);
}

void publish_ventilation_status(void) {
    // Create JSON document using cJSON
    cJSON *doc = cJSON_CreateObject();
    cJSON_AddStringToObject(doc, "status", ventilationStatus);
    cJSON_AddNumberToObject(doc, "percent", current_ventilation_percent);
    cJSON_AddBoolToObject(doc, "auto_control", ventilation_control_auto_state);
    cJSON_AddStringToObject(doc, "greenhouse_id", greenhouse_id);
    
    char *json_string = cJSON_Print(doc);
    
    send_mqtt_data(topic_ventilation_status, json_string);
    
    // Free allocated memory
    free(json_string);
    cJSON_Delete(doc);
}

// Реализация обработчика MQTT сообщений
void handle_mqtt_message(const char* topic, const char* data, int data_len) {
    ESP_LOGI(TAG, "Processing MQTT message, topic: %s, data: %s", topic, data);
    
    // Relay commands
    if (strcmp(topic, topic_relay_command) == 0) {
        // Обработка команды реле
        if (strstr(data, "r1_ON") != NULL) {
            turn_on_relay(1);
            save_relay_state();
        } else if (strstr(data, "r1_OFF") != NULL) {
            turn_off_relay(1);
            save_relay_state();
        } else if (strstr(data, "r2_ON") != NULL) {
            turn_on_relay(2);
            save_relay_state();
        } else if (strstr(data, "r2_OFF") != NULL) {
            turn_off_relay(2);
            save_relay_state();
        } else if (strstr(data, "r3_ON") != NULL) {
            turn_on_relay(3);
            save_relay_state();
        } else if (strstr(data, "r3_OFF") != NULL) {
            turn_off_relay(3);
            save_relay_state();
        } else if (strstr(data, "r4_ON") != NULL) {
            turn_on_relay(4);
            save_relay_state();
        } else if (strstr(data, "r4_OFF") != NULL) {
            turn_off_relay(4);
            save_relay_state();
        }
    } 
    // Sensor read requests
    else if (strcmp(topic, topic_sht20_read) == 0 && strstr(data, "request") != NULL) {
        publish_sht20_data();
    }
    // Ventilation commands
    else if (strcmp(topic, topic_ventilation_command) == 0) {
        // Парсинг JSON
        cJSON *root = cJSON_Parse(data);
        if (root != NULL) {
            // Проверяем, адресовано ли сообщение этой теплице
            cJSON *target_greenhouse = cJSON_GetObjectItem(root, "target_greenhouse");
            if (target_greenhouse && cJSON_IsString(target_greenhouse) && 
                strcmp(target_greenhouse->valuestring, greenhouse_id) != 0) {
                ESP_LOGI(TAG, "Message is for a different greenhouse. Ignoring.");
                cJSON_Delete(root);
                return;
            }
            
            // Проверяем action
            cJSON *action = cJSON_GetObjectItem(root, "action");
            if (action) {
                if (cJSON_IsNumber(action)) {
                    // Численное значение для открытия вентиляции на процент
                    int target_percent = action->valueint;
                    ventilation_control_open_percent(target_percent);
                    save_ventilation_settings();
                } 
                else if (cJSON_IsString(action)) {
                    // Строковая команда (auto/manual)
                    const char *cmd = action->valuestring;
                    if (strcmp(cmd, "auto") == 0) {
                        ventilation_control_auto_state = true;
                        ventilation_control_open_percent(0);
                        ventilation_control_auto();
                        save_ventilation_settings();
                    } 
                    else if (strcmp(cmd, "manual") == 0) {
                        ventilation_control_auto_state = false;
                        ventilation_control_open_percent(0);
                        save_ventilation_settings();
                    }
                    else if (strcmp(cmd, "get") == 0) {
                        publish_ventilation_status();
                    }
                }
            }
            
            cJSON_Delete(root);
        }
    }
    // Ventilation setpoints
    else if (strcmp(topic, ventilation_setpoints) == 0) {
        cJSON *root = cJSON_Parse(data);
        if (root != NULL) {
            // Проверяем, адресовано ли сообщение этой теплице
            cJSON *target_greenhouse = cJSON_GetObjectItem(root, "target_greenhouse");
            if (target_greenhouse && cJSON_IsString(target_greenhouse) && 
                strcmp(target_greenhouse->valuestring, greenhouse_id) != 0) {
                ESP_LOGI(TAG, "Message is for a different greenhouse. Ignoring.");
                cJSON_Delete(root);
                return;
            }
            
            float temp_setpoint = ventilation_temperature_setpoint;
            int coef_setpoint = ventilation_open_coefficient;
            int wind_setpoint = ventilation_wind_speed_setpoint;
            float emerg_temp = ventilation_emergency_off_temperature;
            
            cJSON *tempItem = cJSON_GetObjectItem(root, "ventilation_setpoint_temperature");
            if (tempItem && cJSON_IsNumber(tempItem)) {
                temp_setpoint = tempItem->valuedouble;
            }
            
            cJSON *coeffItem = cJSON_GetObjectItem(root, "ventilation_setpoint_coefficient");
            if (coeffItem && cJSON_IsNumber(coeffItem)) {
                coef_setpoint = coeffItem->valueint;
            }
            
            cJSON *windItem = cJSON_GetObjectItem(root, "ventilation_setpoint_wind_speed");
            if (windItem && cJSON_IsNumber(windItem)) {
                wind_setpoint = windItem->valueint;
            }
            
            cJSON *emergItem = cJSON_GetObjectItem(root, "ventilation_emergency_off_temperature");
            if (emergItem && cJSON_IsNumber(emergItem)) {
                emerg_temp = emergItem->valuedouble;
            }
            
            setVentilationSetpoints(temp_setpoint, coef_setpoint, wind_setpoint, emerg_temp);
            
            cJSON_Delete(root);
        }
    }
    else if (strcmp(topic, ventilation_setpoints_get) == 0 && strstr(data, "get") != NULL) {
        publishVentilationSetpoints();
    }
    // Greenhouse status
    else if (strcmp(topic, topic_greenhouse_status_get) == 0) {
        publishGreenhouseStatus();
    }
    
    // Cooling topics
    else if (strcmp(topic, topic_cooling_setpoints_get) == 0 && strstr(data, "get") != NULL) {
        publishCoolingSetpoints();
    }
    else if (strcmp(topic, topic_cooling_setpoints) == 0) {
        cJSON *root = cJSON_Parse(data);
        if (root != NULL) {
            // Проверяем, адресовано ли сообщение этой теплице
            cJSON *target_greenhouse = cJSON_GetObjectItem(root, "target_greenhouse");
            if (target_greenhouse && cJSON_IsString(target_greenhouse) && 
                strcmp(target_greenhouse->valuestring, greenhouse_id) != 0) {
                ESP_LOGI(TAG, "Message is for a different greenhouse. Ignoring.");
                cJSON_Delete(root);
                return;
            }
            
            float target_temp = cooling_target_temperature;
            float emerg_temp = cooling_emergency_off_temperature;
            bool auto_state = cooling_control_auto_state;
            
            cJSON *tempItem = cJSON_GetObjectItem(root, "cooling_setpoint_temperature");
            if (tempItem && cJSON_IsNumber(tempItem)) {
                target_temp = tempItem->valuedouble;
            }
            
            cJSON *emergItem = cJSON_GetObjectItem(root, "cooling_emergency_off_temperature");
            if (emergItem && cJSON_IsNumber(emergItem)) {
                emerg_temp = emergItem->valuedouble;
            }
            
            cJSON *autoItem = cJSON_GetObjectItem(root, "cooling_control_auto_state");
            if (autoItem && cJSON_IsBool(autoItem)) {
                auto_state = cJSON_IsTrue(autoItem);
            }
            
            setCoolingSetpoints(target_temp, emerg_temp, auto_state);
            
            cJSON_Delete(root);
        }
    }
    else if (strcmp(topic, topic_cooling_status) == 0 && strstr(data, "get") != NULL) {
        publishCoolingStatus();
    }
    else if (strcmp(topic, topic_cooling_command) == 0) {
        // Парсинг JSON
        cJSON *root = cJSON_Parse(data);
        if (root != NULL) {
            // Проверяем, адресовано ли сообщение этой теплице
            cJSON *target_greenhouse = cJSON_GetObjectItem(root, "target_greenhouse");
            if (target_greenhouse && cJSON_IsString(target_greenhouse) && 
                strcmp(target_greenhouse->valuestring, greenhouse_id) != 0) {
                ESP_LOGI(TAG, "Message is for a different greenhouse. Ignoring.");
                cJSON_Delete(root);
                return;
            }
            
            // Проверяем action
            cJSON *action = cJSON_GetObjectItem(root, "action");
            if (action) {
                if (cJSON_IsNumber(action)) {
                    // Численное значение для запуска охлаждения на процент
                    int percent = action->valueint;
                    cooling_system_start(percent);
                } 
                else if (cJSON_IsString(action)) {
                    // Строковая команда (auto/manual)
                    const char *cmd = action->valuestring;
                    if (strcmp(cmd, "auto") == 0) {
                        cooling_control_auto_state = true;
                        cooling_control_auto();
                        save_cooling_settings();
                    } 
                    else if (strcmp(cmd, "manual") == 0) {
                        cooling_control_auto_state = false;
                        cooling_system_stop();
                        save_cooling_settings();
                    }
                }
            }
            
            cJSON_Delete(root);
        }
    }
    else if (strcmp(topic, topic_cooling_command_ventilator_start) == 0) {
        // Парсинг JSON для определения номера вентилятора
        cJSON *root = cJSON_Parse(data);
        if (root != NULL) {
            cJSON *action = cJSON_GetObjectItem(root, "action");
            if (action && cJSON_IsNumber(action)) {
                int ventilator_num = action->valueint;
                startVentilator(ventilator_num);
            }
            cJSON_Delete(root);
        }
    }
    else if (strcmp(topic, topic_cooling_command_ventilator_stop) == 0) {
        // Парсинг JSON для определения номера вентилятора
        cJSON *root = cJSON_Parse(data);
        if (root != NULL) {
            cJSON *action = cJSON_GetObjectItem(root, "action");
            if (action && cJSON_IsNumber(action)) {
                int ventilator_num = action->valueint;
                stopVentilator(ventilator_num);
            }
            cJSON_Delete(root);
        }
    }
    // Relay status requests
    else if (strcmp(topic, topic_relay_status_get) == 0) {
        if (strstr(data, "all") != NULL) {
            publishAllRelayStatus();
        } else {
            // Check if it's a specific relay request
            if (strstr(data, "r1") != NULL) publishRelayStatus(1);
            else if (strstr(data, "r2") != NULL) publishRelayStatus(2);
            else if (strstr(data, "r3") != NULL) publishRelayStatus(3);
            else if (strstr(data, "r4") != NULL) publishRelayStatus(4);
        }
    }
    
    // Добавить обработку других команд по аналогии с Arduino кодом
}

// Функции для работы с NVS (Non-Volatile Storage)
esp_err_t nvs_save_bool(const char *key, bool value) {
    nvs_handle_t my_handle;
    esp_err_t err;
    
    err = nvs_open(NVS_NAMESPACE, NVS_READWRITE, &my_handle);
    if (err != ESP_OK) return err;
    
    err = nvs_set_u8(my_handle, key, (uint8_t)value);
    if (err != ESP_OK) {
        nvs_close(my_handle);
        return err;
    }
    
    err = nvs_commit(my_handle);
    nvs_close(my_handle);
    return err;
}

esp_err_t nvs_save_int(const char *key, int32_t value) {
    nvs_handle_t my_handle;
    esp_err_t err;
    
    err = nvs_open(NVS_NAMESPACE, NVS_READWRITE, &my_handle);
    if (err != ESP_OK) return err;
    
    err = nvs_set_i32(my_handle, key, value);
    if (err != ESP_OK) {
        nvs_close(my_handle);
        return err;
    }
    
    err = nvs_commit(my_handle);
    nvs_close(my_handle);
    return err;
}

esp_err_t nvs_save_float(const char *key, float value) {
    // В NVS нет прямой поддержки float, поэтому преобразуем в int32_t
    int32_t int_value;
    memcpy(&int_value, &value, sizeof(int32_t));
    return nvs_save_int(key, int_value);
}

bool nvs_get_bool(const char *key, bool default_value) {
    nvs_handle_t my_handle;
    esp_err_t err;
    uint8_t value = default_value;
    
    err = nvs_open(NVS_NAMESPACE, NVS_READONLY, &my_handle);
    if (err != ESP_OK) return default_value;
    
    err = nvs_get_u8(my_handle, key, &value);
    nvs_close(my_handle);
    
    if (err != ESP_OK) return default_value;
    return (bool)value;
}

int32_t nvs_get_int(const char *key, int32_t default_value) {
    nvs_handle_t my_handle;
    esp_err_t err;
    int32_t value = default_value;
    
    err = nvs_open(NVS_NAMESPACE, NVS_READONLY, &my_handle);
    if (err != ESP_OK) return default_value;
    
    err = nvs_get_i32(my_handle, key, &value);
    nvs_close(my_handle);
    
    if (err != ESP_OK) return default_value;
    return value;
}

float nvs_get_float(const char *key, float default_value) {
    // Получаем int32_t и конвертируем его в float
    int32_t int_value = nvs_get_int(key, 0);
    
    // Если значение не было найдено, возвращаем default_value
    if (int_value == 0 && nvs_get_int(key, 1) == 1) {
        return default_value;
    }
    
    float value;
    memcpy(&value, &int_value, sizeof(float));
    return value;
}

// Сохранение настроек вентиляции
void save_ventilation_settings(void) {
    ESP_LOGI(TAG, "Saving ventilation settings to NVS");
    nvs_save_bool("vent_auto", ventilation_control_auto_state);
    nvs_save_float("vent_temp", ventilation_temperature_setpoint);
    nvs_save_int("vent_coef", ventilation_open_coefficient);
    nvs_save_int("vent_wind", ventilation_wind_speed_setpoint);
    nvs_save_float("vent_emerg", ventilation_emergency_off_temperature);
}

// Сохранение настроек охлаждения
void save_cooling_settings(void) {
    ESP_LOGI(TAG, "Saving cooling settings to NVS");
    nvs_save_bool("cool_auto", cooling_control_auto_state);
    nvs_save_float("cool_temp", cooling_target_temperature);
    nvs_save_float("cool_emerg", cooling_emergency_off_temperature);
    nvs_save_bool("cool_active", cooling_system_active);
    
    for(int i = 0; i < sizeof(cooling_ventilators_status)/sizeof(cooling_ventilators_status[0]); i++) {
        char key[8];
        snprintf(key, sizeof(key), "v%d", i+1);
        nvs_save_bool(key, cooling_ventilators_status[i]);
    }
    
    nvs_save_bool("water_pump", cooling_water_pump_status);
}

// Функции для установки настроек
void setVentilationSetpoints(float temperature, int coefficient, int windSpeed, float emergency_off_temperature) {
    ventilation_temperature_setpoint = temperature;
    ventilation_open_coefficient = coefficient;
    ventilation_wind_speed_setpoint = windSpeed;
    ventilation_emergency_off_temperature = emergency_off_temperature;
    save_ventilation_settings();
    publishVentilationSetpoints();
}

void setCoolingSetpoints(float target_temperature, float emergency_off_temperature, bool control_auto_state) {
    cooling_target_temperature = target_temperature;
    cooling_emergency_off_temperature = emergency_off_temperature;
    cooling_control_auto_state = control_auto_state;
    save_cooling_settings();
    publishCoolingSetpoints();
}

void publishGreenhouseStatus(void) {
    cJSON *doc = cJSON_CreateObject();
    cJSON_AddStringToObject(doc, "status", "online");
    cJSON_AddStringToObject(doc, "client_id", mqtt_client_id);
    cJSON_AddStringToObject(doc, "greenhouse_id", greenhouse_id);
    
    char *json_string = cJSON_Print(doc);
    send_mqtt_data(topic_greenhouse_status, json_string);
    
    free(json_string);
    cJSON_Delete(doc);
}

void publishVentilationSetpoints(void) {
    cJSON *doc = cJSON_CreateObject();
    cJSON_AddNumberToObject(doc, "temperature", ventilation_temperature_setpoint);
    cJSON_AddNumberToObject(doc, "coefficient", ventilation_open_coefficient);
    cJSON_AddNumberToObject(doc, "wind_speed", ventilation_wind_speed_setpoint);
    cJSON_AddNumberToObject(doc, "emergency_off_temperature", ventilation_emergency_off_temperature);
    cJSON_AddStringToObject(doc, "greenhouse_id", greenhouse_id);
    
    char *json_string = cJSON_Print(doc);
    send_mqtt_data(ventilation_setpoints_get, json_string);
    
    free(json_string);
    cJSON_Delete(doc);
}

void publishCoolingSetpoints(void) {
    cJSON *doc = cJSON_CreateObject();
    cJSON_AddNumberToObject(doc, "target_temperature", cooling_target_temperature);
    cJSON_AddNumberToObject(doc, "emergency_off_temperature", cooling_emergency_off_temperature);
    cJSON_AddBoolToObject(doc, "control_auto_state", cooling_control_auto_state);
    cJSON_AddStringToObject(doc, "client_id", mqtt_client_id);
    cJSON_AddStringToObject(doc, "greenhouse_id", greenhouse_id);
    
    char *json_string = cJSON_Print(doc);
    send_mqtt_data(topic_cooling_setpoints, json_string);
    
    free(json_string);
    cJSON_Delete(doc);
}

void publishCoolingStatus(void) {
    cJSON *doc = cJSON_CreateObject();
    cJSON_AddBoolToObject(doc, "status", cooling_system_active);
    
    // Создаем массив для статуса вентиляторов
    cJSON *ventilators = cJSON_CreateArray();
    for (int i = 0; i < sizeof(cooling_ventilators_status)/sizeof(cooling_ventilators_status[0]); i++) {
        cJSON_AddItemToArray(ventilators, cJSON_CreateBool(cooling_ventilators_status[i]));
    }
    cJSON_AddItemToObject(doc, "ventilators", ventilators);
    
    cJSON_AddBoolToObject(doc, "water_pump", cooling_water_pump_status);
    cJSON_AddBoolToObject(doc, "cooling_control_auto_state", cooling_control_auto_state);
    cJSON_AddStringToObject(doc, "client_id", mqtt_client_id);
    cJSON_AddStringToObject(doc, "greenhouse_id", greenhouse_id);
    
    char *json_string = cJSON_Print(doc);
    send_mqtt_data(topic_cooling_status, json_string);
    
    free(json_string);
    cJSON_Delete(doc);
}

void publishAllRelayStatus(void) {
    cJSON *doc = cJSON_CreateObject();
    cJSON_AddStringToObject(doc, "r1", relayStatus[0] ? "ON" : "OFF");
    cJSON_AddStringToObject(doc, "r2", relayStatus[1] ? "ON" : "OFF");
    cJSON_AddStringToObject(doc, "r3", relayStatus[2] ? "ON" : "OFF");
    cJSON_AddStringToObject(doc, "r4", relayStatus[3] ? "ON" : "OFF");
    cJSON_AddStringToObject(doc, "greenhouse_id", greenhouse_id);
    
    char *json_string = cJSON_Print(doc);
    send_mqtt_data(topic_relay_status, json_string);
    
    free(json_string);
    cJSON_Delete(doc);
}

void publishRelayStatus(int relayIndex) {
    if (relayIndex < 1 || relayIndex > 4) return;
    
    char relayId[3];
    snprintf(relayId, sizeof(relayId), "r%d", relayIndex);
    int relay = relayIndex - 1;
    
    cJSON *doc = cJSON_CreateObject();
    cJSON_AddStringToObject(doc, relayId, relayStatus[relay] ? "ON" : "OFF");
    cJSON_AddStringToObject(doc, "greenhouse_id", greenhouse_id);
    
    char *json_string = cJSON_Print(doc);
    send_mqtt_data(topic_relay_status, json_string);
    
    free(json_string);
    cJSON_Delete(doc);
}